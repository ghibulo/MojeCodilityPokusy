// vim: set syntax=asciidoc:

= Moje řešení
:source-highlighter: coderay
:coderay-linenums-mode: inline
:coderay-css: class
Jirka Hrbek <jirka.hrbek@google.com>
:toc:
:toc-title: Obsah
:icons: font
:imagesdir: obrazky
:quick-uri: http://asciidoctor.org/docs/asciidoc-syntax-quick-reference/
:blank: pass:[ +]

:bigblank: pass:[ <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>]



:toc-title: Název
:caution-caption: Pozor
:important-caption: Důležité
:note-caption: Poznámka
:tip-caption: Myšlenka
:warning-caption: Warnung
:appendix-caption: Anhang
:example-caption: Příklad
:figure-caption: Obrázek
:table-caption: Tabulka



== C++

=== GenomicRangeQuery

- _Pro tuhle úlohu jsem si musel nastudovat tento elegantní přístup rozdělení celého pole do částí, které jsou velikostně mocninou 2^x a snadno se tak určuje minimální prvek pro následující větší oblast. Efektivita mé třídy findArrMin byla spočtena O(n+m)_
  https://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/#Range_Minimum_Query_%28RMQ%29

A DNA sequence can be represented as a string consisting of the letters A, C, G and T, which correspond to the types of successive nucleotides in the sequence. Each nucleotide has an impact factor, which is an integer. Nucleotides of types A, C, G and T have impact factors of 1, 2, 3 and 4, respectively. You are going to answer several queries of the form: What is the minimal impact factor of nucleotides contained in a particular part of the given DNA sequence?

The DNA sequence is given as a non-empty string S = S[0]S[1]...S[N-1] consisting of N characters. There are M queries, which are given in non-empty arrays P and Q, each consisting of M integers. The K-th query (0 ≤ K < M) requires you to find the minimal impact factor of nucleotides contained in the DNA sequence between positions P[K] and Q[K] (inclusive).

For example, consider string S = CAGCCTA and arrays P, Q such that:

    P[0] = 2    Q[0] = 4
    P[1] = 5    Q[1] = 5
    P[2] = 0    Q[2] = 6
The answers to these M = 3 queries are as follows:

The part of the DNA between positions 2 and 4 contains nucleotides G and C (twice), whose impact factors are 3 and 2 respectively, so the answer is 2.
The part between positions 5 and 5 contains a single nucleotide T, whose impact factor is 4, so the answer is 4.
The part between positions 0 and 6 (the whole string) contains all nucleotides, in particular nucleotide A whose impact factor is 1, so the answer is 1.
Write a function:

vector<int> solution(string &S, vector<int> &P, vector<int> &Q);

that, given a non-empty zero-indexed string S consisting of N characters and two non-empty zero-indexed arrays P and Q consisting of M integers, returns an array consisting of M integers specifying the consecutive answers to all queries.

The sequence should be returned as:

a Results structure (in C), or
a vector of integers (in C++), or
a Results record (in Pascal), or
an array of integers (in any other programming language).
For example, given the string S = CAGCCTA and arrays P, Q such that:

    P[0] = 2    Q[0] = 4
    P[1] = 5    Q[1] = 5
    P[2] = 0    Q[2] = 6
the function should return the values [2, 4, 1], as explained above.

Assume that:

N is an integer within the range [1..100,000];
M is an integer within the range [1..50,000];
each element of arrays P, Q is an integer within the range [0..N − 1];
P[K] ≤ Q[K], where 0 ≤ K < M;
string S consists only of upper-case English letters A, C, G, T.
Complexity:

expected worst-case time complexity is O(N+M);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.

[source,cpp]
----

#include <vector>
#include <math.h>

using std::vector;
using namespace std;

class findArrMin {
private:
    vector<int> &farr;
    vector<vector <int>> M;

    int getMinPos(int s, int n) {
        int min = farr[s];
        int pos = s;
        for (int i=s+1;i<s+n;i++) {
            if (farr[i]<min) {
                min = farr[i];pos = i;
            }
        }
        return pos;
    }


public:


    findArrMin (vector<int> &ar):farr(ar){
        preprocessing();
    }

    void preprocessing() {

        unsigned long N = farr.size();
        unsigned long siz = (unsigned long)log2(N);
        for(unsigned int i=0;i<N;i++){
            vector<int> el(siz,0);
            el[0]=i; //interval length 1 -> minimum always the same element
            M.push_back(el);
        }
        //vyssi intervaly nez 1
        for (unsigned long j = 1; (unsigned long)(1 << j) <= N; j++) //j in <1,k> where 2^k <= N
            for (unsigned long i = 0; i + (1 << j) - 1 < N; i++)
                //bud minimum z prvni poloviny intervalu,
                if (farr[M[i][j - 1]] < farr[M[i + (1 << (j - 1))][j - 1]])
                    M[i][j] = M[i][j - 1];
                else  //...,nebo z druhe
                    M[i][j] = M[i + (1 << (j - 1))][j - 1];

    }

    int getMinFromInterval(long int i, long int j) {
        unsigned long  k = (unsigned long) log2(j-i+1);
        return (farr[M[i][k]]<= farr[M[j-(1<<k)+1][k]])?M[i][k]:M[j-(1<<k)+1][k];
    }

};


vector<int> preklad(string S){
    char p[4][2] = {{65,1},{67,2},{71,3},{84,4}};
    vector<int> res;
    for(unsigned int i=0;i<S.length();i++) {
        for(int j=0;j<4;j++) {
            if (S[i] == p[j][0]) {
                res.push_back(p[j][1]);
                break;
            }
        }
    }
    return res;
}


vector<int> solution(string &S, vector<int> &P, vector<int> &Q) {
    vector<int> pole = preklad(S);
    vector<int> res;
    if (S.length()>1) {
        findArrMin hledac(pole);
        for(unsigned int i=0;i<P.size();i++) {
                res.push_back(pole[hledac.getMinFromInterval(P[i],Q[i])]);
        }
    } else {
        for(unsigned int i=0;i<P.size();i++) {
            res.push_back(pole[0]);
        }
    }
    return res;
}

----




=== Zadání MaxCounters:

You are given N counters, initially set to 0, and you have two possible operations on them:

increase(X) − counter X is increased by 1,
max counter − all counters are set to the maximum value of any counter.
A non-empty zero-indexed array A of M integers is given. This array represents consecutive operations:

if A[K] = X, such that 1 ≤ X ≤ N, then operation K is increase(X),
if A[K] = N + 1 then operation K is max counter.
For example, given integer N = 5 and array A such that:

    A[0] = 3
    A[1] = 4
    A[2] = 4
    A[3] = 6
    A[4] = 1
    A[5] = 4
    A[6] = 4
the values of the counters after each consecutive operation will be:

    (0, 0, 1, 0, 0)
    (0, 0, 1, 1, 0)
    (0, 0, 1, 2, 0)
    (2, 2, 2, 2, 2)
    (3, 2, 2, 2, 2)
    (3, 2, 2, 3, 2)
    (3, 2, 2, 4, 2)
The goal is to calculate the value of every counter after all operations.

Write a function:

vector<int> solution(int N, vector<int> &A);
that, given an integer N and a non-empty zero-indexed array A consisting of M integers, returns a sequence of integers representing the values of the counters.

The sequence should be returned as:

a structure Results (in C), or
a vector of integers (in C++), or
a record Results (in Pascal), or
an array of integers (in any other programming language).
For example, given:

    A[0] = 3
    A[1] = 4
    A[2] = 4
    A[3] = 6
    A[4] = 1
    A[5] = 4
    A[6] = 4
the function should return [3, 2, 2, 4, 2], as explained above.

Assume that:

N and M are integers within the range [1..100,000];
each element of array A is an integer within the range [1..N + 1].
Complexity:

expected worst-case time complexity is O(N+M);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.


[source,cpp]
----
#include <iostream>
#include <vector>
#include <algorithm>

using std::vector;

vector<int> solution(int N, vector<int> &A) {
    vector<int> res;
    //init res
    for(int i=0; i<N; i++) res.push_back(0);

    vector<int>::iterator i;
    int max=0;
    int inf=0;
    for(i=A.begin();i!=A.end();i++)
        if (*i<=N) {
            res[*i-1] = (res[*i-1]<inf)?(inf+1):res[*i-1]+1;
            max = (max>res[*i-1])?max:res[*i-1];
        } else {
           //for (int j=0;j<N;j++) res[j]=max;
            inf=max;
        }
    for (int j=0;j<N;j++) if (res[j]<inf) res[j]=inf;

    return res;
}

----

=== CountDiv

Write a function:

int solution(int A, int B, int K);

that, given three integers A, B and K, returns the number of integers within the range [A..B] that are divisible by K, i.e.:

{ i : A ≤ i ≤ B, i mod K = 0 }

For example, for A = 6, B = 11 and K = 2, your function should return 3, because there are three numbers divisible by 2 within the range [6..11], namely 6, 8 and 10.

Assume that:

A and B are integers within the range [0..2,000,000,000];
K is an integer within the range [1..2,000,000,000];
A ≤ B.
Complexity:

expected worst-case time complexity is O(1);
expected worst-case space complexity is O(1).





[source,cpp]
----

int solution2b(int A, int B, int K) {
    int pom = A%K;
    int st = A+((pom!=0)?(K-pom):0);
    if (st>B)
        return 0;
    int pocet = (B-st)/K;
    return pocet+1;
}
----

=== PassingCars

Task description
A non-empty zero-indexed array A consisting of N integers is given. The consecutive elements of array A represent consecutive cars on a road.

Array A contains only 0s and/or 1s:

0 represents a car traveling east,
1 represents a car traveling west.
The goal is to count passing cars. We say that a pair of cars (P, Q), where 0 ≤ P < Q < N, is passing when P is traveling to the east and Q is traveling to the west.

For example, consider array A such that:

  A[0] = 0
  A[1] = 1
  A[2] = 0
  A[3] = 1
  A[4] = 1
We have five pairs of passing cars: (0, 1), (0, 3), (0, 4), (2, 3), (2, 4).

Write a function:

int solution(vector<int> &A);

that, given a non-empty zero-indexed array A of N integers, returns the number of pairs of passing cars.

The function should return −1 if the number of pairs of passing cars exceeds 1,000,000,000.

For example, given:

  A[0] = 0
  A[1] = 1
  A[2] = 0
  A[3] = 1
  A[4] = 1
the function should return 5, as explained above.

Assume that:

N is an integer within the range [1..100,000];
each element of array A is an integer that can have one of the following values: 0, 1.
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(1), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.


[source,cpp]
----
int solution(vector<int> &A) {


    vector<int>::reverse_iterator i;
    int n1 =0, n0=0, res=0;
    for(i=A.rbegin();i!=A.rend();++i) {
        if (*i) {
            ++n1;
        } else {
            ++n0;
            res+=n1;
            if (res>1000000000) return -1;
        }
    }
    return res;
}
----



== Java


=== MissingInteger

Write a function:

class Solution { public int solution(int[] A); }
that, given a non-empty zero-indexed array A of N integers, returns the minimal positive integer (greater than 0) that does not occur in A.

For example, given:

  A[0] = 1
  A[1] = 3
  A[2] = 6
  A[3] = 4
  A[4] = 1
  A[5] = 2
the function should return 5.

Assume that:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−2,147,483,648..2,147,483,647].
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.

[source,javascript]
----
    public static int solution(int[] A) {
        int [] Z = new int[100000];


            for (int j=0;j<A.length;j++) {
                if ((A[j]>0)&&(A[j]<=100000)) Z[A[j]-1]=1;
            }
            for (int j=0;j<Z.length;j++) if (Z[j]==0) return j+1;
            return 100001;
    }
----




=== FrogRiverOne

A small frog wants to get to the other side of a river. The frog is initially located on one bank of the river (position 0) and wants to get to the opposite bank (position X+1). Leaves fall from a tree onto the surface of the river.

You are given a zero-indexed array A consisting of N integers representing the falling leaves. A[K] represents the position where one leaf falls at time K, measured in seconds.

The goal is to find the earliest time when the frog can jump to the other side of the river. The frog can cross only when leaves appear at every position across the river from 1 to X (that is, we want to find the earliest moment when all the positions from 1 to X are covered by leaves). You may assume that the speed of the current in the river is negligibly small, i.e. the leaves do not change their positions once they fall in the river.

For example, you are given integer X = 5 and array A such that:

  A[0] = 1
  A[1] = 3
  A[2] = 1
  A[3] = 4
  A[4] = 2
  A[5] = 3
  A[6] = 5
  A[7] = 4
In second 6, a leaf falls into position 5. This is the earliest time when leaves appear in every position across the river.

Write a function:

class Solution { public int solution(int X, int[] A); }
that, given a non-empty zero-indexed array A consisting of N integers and integer X, returns the earliest time when the frog can jump to the other side of the river.

If the frog is never able to jump to the other side of the river, the function should return −1.

For example, given X = 5 and array A such that:

  A[0] = 1
  A[1] = 3
  A[2] = 1
  A[3] = 4
  A[4] = 2
  A[5] = 3
  A[6] = 5
  A[7] = 4
the function should return 6, as explained above.

Assume that:

N and X are integers within the range [1..100,000];
each element of array A is an integer within the range [1..X].
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(X), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.

[source,java]
----


    public static int check(boolean[]p, int from) {
        for(int i=from;i<p.length;i++) {
            if (!p[i]) return i-1;
        }
        return p.length-1;
    }

    public static int solution2(int X, int[] A) {
        boolean []p=new boolean[X+1];
        int from=1;

        for(int i=0;i<A.length;i++) {
            if (A[i]<=X) p[A[i]]=true;
            from = check(p,from);
            from = (from<1)?1:from;
            if (from == X) return i;
        }
        //for(int i=0;i<X;i++) System.out.println(p[i]);
        return -1;
    }
----



=== Zadání PermCheck

A non-empty zero-indexed array A consisting of N integers is given.

A permutation is a sequence containing each element from 1 to N once, and only once.

For example, array A such that:

    A[0] = 4
    A[1] = 1
    A[2] = 3
    A[3] = 2
is a permutation, but array A such that:

    A[0] = 4
    A[1] = 1
    A[2] = 3
is not a permutation, because value 2 is missing.

The goal is to check whether array A is a permutation.

Write a function:

class Solution { public int solution(int[] A); }
that, given a zero-indexed array A, returns 1 if array A is a permutation and 0 if it is not.

For example, given array A such that:

    A[0] = 4
    A[1] = 1
    A[2] = 3
    A[3] = 2
the function should return 1.

Given array A such that:

    A[0] = 4
    A[1] = 1
    A[2] = 3
the function should return 0.

Assume that:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [1..1,000,000,000].
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.

[source,javascript]
----
    public static int solution3(int[] A) {
        boolean []p = new boolean[A.length+1];
        for (int i=0;i<A.length;i++) {
            if ((A[i]>=p.length)||(A[i]<1)||(p[A[i]])) return 0; else p[A[i]]=true;
        }
        int i=1;
        while (p[i++] && i<p.length);
        return (i==p.length)?1:0;
    }

----



=== Triangle

- *trojúhelníková nerovnost* - _hodilo mi to 93% správnost, vypadlo to u nějakých extrémních čísel MAXINT - takže zřejmě chybička přetečení. Čas jsem ušetřil na záporných hodnotách, pro které takto pojatá „trojúhelníková nerovnost“ platit nemůže._

Task description
A zero-indexed array A consisting of N integers is given. A triplet (P, Q, R) is triangular if 0 ≤ P < Q < R < N and:

A[P] + A[Q] > A[R],
A[Q] + A[R] > A[P],
A[R] + A[P] > A[Q].
For example, consider array A such that:

  A[0] = 10    A[1] = 2    A[2] = 5
  A[3] = 1     A[4] = 8    A[5] = 20
Triplet (0, 2, 4) is triangular.

Write a function:

class Solution { public int solution(int[] A); }

that, given a zero-indexed array A consisting of N integers, returns 1 if there exists a triangular triplet for this array and returns 0 otherwise.

For example, given array A such that:

  A[0] = 10    A[1] = 2    A[2] = 5
  A[3] = 1     A[4] = 8    A[5] = 20
the function should return 1, as explained above. Given array A such that:

  A[0] = 10    A[1] = 50    A[2] = 5
  A[3] = 1
the function should return 0.

Assume that:

N is an integer within the range [0..100,000];
each element of array A is an integer within the range [−2,147,483,648..2,147,483,647].
Complexity:

expected worst-case time complexity is O(N*log(N));
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.

[source,javascript]
----
class Solution {

    public int solution(int[] A) {
        if (A.length<3) return 0;
        Arrays.sort(A);
        int p=A.length;
        for (int i=A.length-1;i>=0;i--) {
            if ((A[i]+A[i-1]>A[i-2])&&(A[i]+A[i-2]>A[i-1])&&(A[i-2]+A[i-1]>A[i])) {
                return 1;
            }
            if ((--p < 3)||(A[p]<=0)) return 0;
        }
        return 0;
    }

}
----


=== MaxProductOfThree 


Task description
A non-empty zero-indexed array A consisting of N integers is given. The product of triplet (P, Q, R) equates to A[P] * A[Q] * A[R] (0 ≤ P < Q < R < N).

For example, array A such that:

  A[0] = -3
  A[1] = 1
  A[2] = 2
  A[3] = -2
  A[4] = 5
  A[5] = 6
contains the following example triplets:

(0, 1, 2), product is −3 * 1 * 2 = −6
(1, 2, 4), product is 1 * 2 * 5 = 10
(2, 4, 5), product is 2 * 5 * 6 = 60
Your goal is to find the maximal product of any triplet.

Write a function:

class Solution { public int solution(int[] A); }

that, given a non-empty zero-indexed array A, returns the value of the maximal product of any triplet.

For example, given array A such that:

  A[0] = -3
  A[1] = 1
  A[2] = 2
  A[3] = -2
  A[4] = 5
  A[5] = 6
the function should return 60, as the product of triplet (2, 4, 5) is maximal.

Assume that:

N is an integer within the range [3..100,000];
each element of array A is an integer within the range [−1,000..1,000].
Complexity:

expected worst-case time complexity is O(N*log(N));
expected worst-case space complexity is O(1), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.


[source,javascript]
----
import java.util.Arrays;

class Solution {

    public  int solution(int[] A) {
        int tr1,tr2;
        Arrays.sort(A);
        if ((A[0]<0)&&(A[1]<0)) tr1=A[0]*A[1]*A[A.length-1]; else tr1=A[0];
        tr2=A[A.length-1]*A[A.length-2]*A[A.length-3];
        return (tr1<tr2)?tr2:tr1;
    }
}
----

=== NumberOfDiscIntersections

_Na tuto úlohu jsem šel hodně zeširoka - vybudoval jsem si množinu, která mi automaticky rozpoznávala, když jsem tam vložil stejnou dvojici. Bylo nutné předefinovat *hashcode* a *equals* přes vnořenou třídu, pak jsem všechny kružnice seřadil podle spodního okraje, abych v cyklu zastavil vždy u kružnice, která už je mimo rozsah. Program funguje, ale za performance jsem dostal nulu (O(n*n)). Přesto sem toto řešení dávám, protože jsem se na něm hodně naučil. Zřejmě jen stačilo bez řazení a „set„ zásobníku počítat v nořeném cyklu překrývající objekty._

Task description
We draw N discs on a plane. The discs are numbered from 0 to N − 1. A zero-indexed array A of N non-negative integers, specifying the radiuses of the discs, is given. The J-th disc is drawn with its center at (J, 0) and radius A[J].

We say that the J-th disc and K-th disc intersect if J ≠ K and the J-th and K-th discs have at least one common point (assuming that the discs contain their borders).

The figure below shows discs drawn for N = 6 and A as follows:

  A[0] = 1
  A[1] = 5
  A[2] = 2
  A[3] = 1
  A[4] = 4
  A[5] = 0


There are eleven (unordered) pairs of discs that intersect, namely:

discs 1 and 4 intersect, and both intersect with all the other discs;
disc 2 also intersects with discs 0 and 3.
Write a function:

class Solution { public int solution(int[] A); }

that, given an array A describing N discs as explained above, returns the number of (unordered) pairs of intersecting discs. The function should return −1 if the number of intersecting pairs exceeds 10,000,000.

Given array A shown above, the function should return 11, as explained above.

Assume that:

N is an integer within the range [0..100,000];
each element of array A is an integer within the range [0..2,147,483,647].
Complexity:

expected worst-case time complexity is O(N*log(N));
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.


[source,javascript]
----
import java.util.Arrays;
import java.util.Set;
import java.util.HashSet;

class Solution {
    static class Kamosi {
        int prvni,druhy;

        Kamosi(int x, int y) {
           prvni=x;druhy=y;
        }
        public boolean equals(Object obj) {
            Kamosi druhadvojice = (Kamosi)obj;
            return ((prvni==druhadvojice.prvni)&&(druhy==druhadvojice.druhy))||
                    ((prvni==druhadvojice.druhy)&&(druhy==druhadvojice.prvni));
        }
        public int hashCode(){
                 return prvni+druhy;
        }
        public String toString() {
            String kamosiInfo = "Kruznice " + prvni+" a kruznice "+druhy + " se dotykaji";
            return kamosiInfo;
        }

    }
    
    static Set<Kamosi> dotykajici = new HashSet<>();

    public static void pridejKamose(int i, int j) {
        dotykajici.add(new Kamosi(i,j));
    }

    public static void vypisKamose() {
       dotykajici.forEach(System.out::println);
    }

    public static boolean najdiKamose(int stred, int polomer,  int[][]psA1) {
        int i=0;
        while (psA1[i][1]<=(stred+polomer))  {
            if (((stred-polomer)<=psA1[i][2])&&(stred != psA1[i][0])) {
                pridejKamose(stred,psA1[i][0]);
            }
            if (psA1.length == ++i) break;
        }
       return dotykajici.size()>10000000;
    }


   
    public int solution(int[] A) {       
       int[][] sA1 = new int[A.length][3];
       if (A.length<2) return 0;
       for (int i=0;i<A.length;i++) {
          sA1[i][0]=i;sA1[i][1]=i-A[i];sA1[i][2]=i+A[i];
       }
       //sort podle spodniho okraje
       Arrays.sort(sA1,(a,b)->a[1]-b[1]);

       for (int i=0;i<A.length;i++) {
           if (najdiKamose(i,A[i],sA1)) return -1;
       }
    
       return dotykajici.size();


    }


}
----



== Python

=== MinAvgTwoSlice

*Tak u této úlohy jsem si vylámal zuby. Nejprve jsem to musel předělat pro interpret 2.7 a i pak jsem po vyhodnocení zjistil, že je můj kod zoufale pomalý (O(n*n)) a dokonce u jednoho nespecifikovaného vstupu vyhodil chybu. Bohužel je tento vstup utajený a tak chybu nemohu odtrasovat. I přes hodnocení 50% sem své řešení uvádím, třeba mě někdy něco napadne, nebo někdo poradí :-)*

- _inspirace od google-> že by stačilo hledat pouze slices velikosti 2 a 3, protože ty větší se z nich skládají, zřejmě vede k větší rychlosti, nebylo by dokonce potřeba vytvářet prefixsums, ale dle mého názoru vytváří teoretickou možnost chybného výsledku, protože průměr průměrů není průměr. Kdo-ví - jestli v tomto případě nejde o tu „chybu“, kterou mi Codility detekovalo! ;-)_


Task description
A non-empty zero-indexed array A consisting of N integers is given. A pair of integers (P, Q), such that 0 ≤ P < Q < N, is called a slice of array A (notice that the slice contains at least two elements). The average of a slice (P, Q) is the sum of A[P] + A[P + 1] + ... + A[Q] divided by the length of the slice. To be precise, the average equals (A[P] + A[P + 1] + ... + A[Q]) / (Q − P + 1).

For example, array A such that:

    A[0] = 4
    A[1] = 2
    A[2] = 2
    A[3] = 5
    A[4] = 1
    A[5] = 5
    A[6] = 8
contains the following example slices:

slice (1, 2), whose average is (2 + 2) / 2 = 2;
slice (3, 4), whose average is (5 + 1) / 2 = 3;
slice (1, 4), whose average is (2 + 2 + 5 + 1) / 4 = 2.5.
The goal is to find the starting position of a slice whose average is minimal.

Write a function:

def solution(A)

that, given a non-empty zero-indexed array A consisting of N integers, returns the starting position of the slice with the minimal average. If there is more than one slice with a minimal average, you should return the smallest starting position of such a slice.

For example, given array A such that:

    A[0] = 4
    A[1] = 2
    A[2] = 2
    A[3] = 5
    A[4] = 1
    A[5] = 5
    A[6] = 8
the function should return 1, as explained above.

Assume that:

N is an integer within the range [2..100,000];
each element of array A is an integer within the range [−10,000..10,000].
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.


[source,python]
----

def makepref(A):
    """vytvoření mezisoučtů"""

    s=0;
    pref = [s]
    for i in A:
        s+=i
        pref.append(s)
    return pref

def getmindif(Pref, d):
    """vrátí dvojici počáteční pozici a nejmenší nalezený průměr
       Pref -> prefix sums zadaného pole A
       d -> jak daleko od sebe P a Q 
    """
    dif = [(i, Pref[i+d]-Pref[i]) for i in range(len(Pref)-d)]
    m = reduce((lambda a,b: a if a[1]<b[1] else b),dif)
    return (m[0],float(m[1])/d)

def solution(A):
    pref=makepref(A) # vytvoří prefixsums
    min=getmindif(pref,2) # vybere nejmenší dvojici
    for i in range(3,len(A)+1): #zkouší další n-tice
        m=getmindif(pref,i)
        if (m[1]<min[1]) or ((m[1] == min[1]) and (m[0]<min[0])): # pokud menší, nebo alespoň blíže počátku
            min=m
    return min[0]
----






