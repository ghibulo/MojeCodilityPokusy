// vim: set syntax=asciidoc:

= Moje řešení
:source-highlighter: coderay
:coderay-linenums-mode: inline
:coderay-css: class
Jirka Hrbek <jirka.hrbek@google.com>
:toc:
:toc-title: Obsah
:icons: font
:imagesdir: obrazky
:quick-uri: http://asciidoctor.org/docs/asciidoc-syntax-quick-reference/
:blank: pass:[ +]

:bigblank: pass:[ <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>]



:toc-title: Název
:caution-caption: Pozor
:important-caption: Důležité
:note-caption: Poznámka
:tip-caption: Myšlenka
:warning-caption: Warnung
:appendix-caption: Anhang
:example-caption: Příklad
:figure-caption: Obrázek
:table-caption: Tabulka



== C++

=== GenomicRangeQuery

- _Pro tuhle úlohu jsem si musel nastudovat tento elegantní přístup rozdělení celého pole do částí, které jsou velikostně mocninou 2^x a snadno se tak určuje minimální prvek pro následující větší oblast. Efektivita mé třídy findArrMin byla spočtena O(n+m)_
  https://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/#Range_Minimum_Query_%28RMQ%29

A DNA sequence can be represented as a string consisting of the letters A, C, G and T, which correspond to the types of successive nucleotides in the sequence. Each nucleotide has an impact factor, which is an integer. Nucleotides of types A, C, G and T have impact factors of 1, 2, 3 and 4, respectively. You are going to answer several queries of the form: What is the minimal impact factor of nucleotides contained in a particular part of the given DNA sequence?

The DNA sequence is given as a non-empty string S = S[0]S[1]...S[N-1] consisting of N characters. There are M queries, which are given in non-empty arrays P and Q, each consisting of M integers. The K-th query (0 ≤ K < M) requires you to find the minimal impact factor of nucleotides contained in the DNA sequence between positions P[K] and Q[K] (inclusive).

For example, consider string S = CAGCCTA and arrays P, Q such that:

    P[0] = 2    Q[0] = 4
    P[1] = 5    Q[1] = 5
    P[2] = 0    Q[2] = 6
The answers to these M = 3 queries are as follows:

The part of the DNA between positions 2 and 4 contains nucleotides G and C (twice), whose impact factors are 3 and 2 respectively, so the answer is 2.
The part between positions 5 and 5 contains a single nucleotide T, whose impact factor is 4, so the answer is 4.
The part between positions 0 and 6 (the whole string) contains all nucleotides, in particular nucleotide A whose impact factor is 1, so the answer is 1.
Write a function:

vector<int> solution(string &S, vector<int> &P, vector<int> &Q);

that, given a non-empty zero-indexed string S consisting of N characters and two non-empty zero-indexed arrays P and Q consisting of M integers, returns an array consisting of M integers specifying the consecutive answers to all queries.

The sequence should be returned as:

a Results structure (in C), or
a vector of integers (in C++), or
a Results record (in Pascal), or
an array of integers (in any other programming language).
For example, given the string S = CAGCCTA and arrays P, Q such that:

    P[0] = 2    Q[0] = 4
    P[1] = 5    Q[1] = 5
    P[2] = 0    Q[2] = 6
the function should return the values [2, 4, 1], as explained above.

Assume that:

N is an integer within the range [1..100,000];
M is an integer within the range [1..50,000];
each element of arrays P, Q is an integer within the range [0..N − 1];
P[K] ≤ Q[K], where 0 ≤ K < M;
string S consists only of upper-case English letters A, C, G, T.
Complexity:

expected worst-case time complexity is O(N+M);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.

[source,cpp]
----

#include <vector>
#include <math.h>

using std::vector;
using namespace std;

class findArrMin {
private:
    vector<int> &farr;
    vector<vector <int>> M;

    int getMinPos(int s, int n) {
        int min = farr[s];
        int pos = s;
        for (int i=s+1;i<s+n;i++) {
            if (farr[i]<min) {
                min = farr[i];pos = i;
            }
        }
        return pos;
    }


public:


    findArrMin (vector<int> &ar):farr(ar){
        preprocessing();
    }

    void preprocessing() {

        unsigned long N = farr.size();
        unsigned long siz = (unsigned long)log2(N);
        for(unsigned int i=0;i<N;i++){
            vector<int> el(siz,0);
            el[0]=i; //interval length 1 -> minimum always the same element
            M.push_back(el);
        }
        //vyssi intervaly nez 1
        for (unsigned long j = 1; (unsigned long)(1 << j) <= N; j++) //j in <1,k> where 2^k <= N
            for (unsigned long i = 0; i + (1 << j) - 1 < N; i++)
                //bud minimum z prvni poloviny intervalu,
                if (farr[M[i][j - 1]] < farr[M[i + (1 << (j - 1))][j - 1]])
                    M[i][j] = M[i][j - 1];
                else  //...,nebo z druhe
                    M[i][j] = M[i + (1 << (j - 1))][j - 1];

    }

    int getMinFromInterval(long int i, long int j) {
        unsigned long  k = (unsigned long) log2(j-i+1);
        return (farr[M[i][k]]<= farr[M[j-(1<<k)+1][k]])?M[i][k]:M[j-(1<<k)+1][k];
    }

};


vector<int> preklad(string S){
    char p[4][2] = {{65,1},{67,2},{71,3},{84,4}};
    vector<int> res;
    for(unsigned int i=0;i<S.length();i++) {
        for(int j=0;j<4;j++) {
            if (S[i] == p[j][0]) {
                res.push_back(p[j][1]);
                break;
            }
        }
    }
    return res;
}


vector<int> solution(string &S, vector<int> &P, vector<int> &Q) {
    vector<int> pole = preklad(S);
    vector<int> res;
    if (S.length()>1) {
        findArrMin hledac(pole);
        for(unsigned int i=0;i<P.size();i++) {
                res.push_back(pole[hledac.getMinFromInterval(P[i],Q[i])]);
        }
    } else {
        for(unsigned int i=0;i<P.size();i++) {
            res.push_back(pole[0]);
        }
    }
    return res;
}

----

=== EquiLeader

- _pro úlohu jsem si vytvořil objekt, který ve dvou instancích přistupuje k jednomu vektorovému poli. Obě instance si namapují počty hodnot na svém úseku, vyhodnotí *leader* a posun probíhá formou inkrementace/dekrementace adres a délky datového pole. Upraví se namapovaný počet jedné hodnoty. Při snížení počtu hodnoty, která byla *leader*em je nutné projít mapu počtů jednotlivých hodnot, což je časově náročné. V ostatních případech však vystačím s již jednou spočtenou hodnotou *max* z toho důvodu se mi nechtělo přesouvat tato data do vhodnější struktury. V hodnocení jsem dostal 100% správnost ale jen 75% výkon, byť ohodnoceno to bylo O(n)_

[source,cpp]
----
#include <iostream>
#include <vector>
#include <map>

using namespace std;

//jaky prvek - kolikrat se objevil
typedef pair<int,unsigned int> Par;
const int NO_VALUE = -1000000001; // values [-1,000,000,000..1,000,000,000]

class Dominator {
private:
    int *start; //prvni prvek pole
    unsigned long num; //pocet
    map<int,unsigned int> prehled; //hodnota,kolikrat
    map<int,unsigned int>::iterator it;
    Par max; //nejvetsti cetnost nejake hodnoty

    void addDelKolik(int co, bool add=true) {
        it = prehled.find(co);
        unsigned int moznaMax  =1;
        if (it != prehled.end()){
            if (add) {
                moznaMax= ++it->second;
            } else {
              it->second--;return; //max nema smysl resit - viz.metoda zmensit
            }
        } else {
            prehled[co]=1;
        }
        if (max.second<moznaMax) {
            max=make_pair(co,moznaMax);
        }
    }

    //zridka pouzivana, jinak predelat
    Par getMax() {
        Par max = make_pair(0,0);
       for(it=prehled.begin();it!=prehled.end();++it){
          if (it->second>max.second) {
              max = make_pair(it->first,it->second);
          }
       }
        return max;
    }

public:
    Dominator(int *astart, unsigned long anum) {
        start = astart;num = anum;max=make_pair(0,0);
        for(unsigned long i=0;i<num;i++) {
            addDelKolik(*(start+i));
        }
    }

    int getLeader() {
        if (num==1) return max.first;
        if (max.second>(num/2)) return max.first; else return NO_VALUE;
    }

    void zvetsit() {
        num++;
        addDelKolik(*(start+num-1));
    }

    void zmensit() {
        int ztraceno = *start;
        start++;num--;
        addDelKolik(ztraceno,false);
        if (ztraceno == max.first){ //bohuzel, ohrozen leader
            max=getMax();
        }
    }
};



int solution(vector<int> &A) {
    // write your code in C++14 (g++ 6.2.0)
    Dominator levy(A.data(),1);
    Dominator pravy(A.data()+1,A.size()-1);
    int ll, pl, pocet=0;
    for (unsigned int i=0;i<A.size();i++) {
        ll = levy.getLeader();
        pl = pravy.getLeader();
        if ((ll!=NO_VALUE)&&(pl!=NO_VALUE)) {
           if (ll==pl) {
               pocet++;
           }
        }
        //cout << "levy:" <<levy.getLeader() << " pravy: " <<pravy.getLeader() << endl;
        levy.zvetsit();
        pravy.zmensit();
    }
    return pocet;
}
----


Task description
A non-empty zero-indexed array A consisting of N integers is given.

The leader of this array is the value that occurs in more than half of the elements of A.

An equi leader is an index S such that 0 ≤ S < N − 1 and two sequences A[0], A[1], ..., A[S] and A[S + 1], A[S + 2], ..., A[N − 1] have leaders of the same value.

For example, given array A such that:

    A[0] = 4
    A[1] = 3
    A[2] = 4
    A[3] = 4
    A[4] = 4
    A[5] = 2
we can find two equi leaders:

0, because sequences: (4) and (3, 4, 4, 4, 2) have the same leader, whose value is 4.
2, because sequences: (4, 3, 4) and (4, 4, 2) have the same leader, whose value is 4.
The goal is to count the number of equi leaders.

Write a function:

int solution(vector<int> &A);

that, given a non-empty zero-indexed array A consisting of N integers, returns the number of equi leaders.

For example, given:

    A[0] = 4
    A[1] = 3
    A[2] = 4
    A[3] = 4
    A[4] = 4
    A[5] = 2
the function should return 2, as explained above.

Assume that:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−1,000,000,000..1,000,000,000].
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.



=== Dominator

- _použit známý postup postupného odebírání různých dvojic (při kterém se denominátor nezmění) vylepšený jen poznámkami do contejneru *map* - což mi umožnilo vyhnout se závěrečné kontrole, jestli zásobníkem vybraný kandidát skutečně překračuje počtem nadpoloviční počet prvků. Řešení ohodnoceno 100%._

Task description
A zero-indexed array A consisting of N integers is given. The dominator of array A is the value that occurs in more than half of the elements of A.

For example, consider array A such that

 A[0] = 3    A[1] = 4    A[2] =  3
 A[3] = 2    A[4] = 3    A[5] = -1
 A[6] = 3    A[7] = 3
The dominator of A is 3 because it occurs in 5 out of 8 elements of A (namely in those with indices 0, 2, 4, 6 and 7) and 5 is more than a half of 8.

Write a function

int solution(vector<int> &A);

that, given a zero-indexed array A consisting of N integers, returns index of any element of array A in which the dominator of A occurs. The function should return −1 if array A does not have a dominator.

Assume that:

N is an integer within the range [0..100,000];
each element of array A is an integer within the range [−2,147,483,648..2,147,483,647].
For example, given array A such that

 A[0] = 3    A[1] = 4    A[2] =  3
 A[3] = 2    A[4] = 3    A[5] = -1
 A[6] = 3    A[7] = 3
the function may return 0, 2, 4, 6 or 7, as explained above.

Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(1), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.

[source,cpp]
----
#include <iostream>
#include <vector>
#include <map>

using namespace std;

int solution(vector<int> &A) {

    int zasobnik;
    int sizezasobnik=0;
    typedef map<int,pair<int,int>> Dict;
    Dict pocty;
    Dict::iterator itpocty;

    //odeberem ruzne -> dominator se nezmeni
    for (int i=0;i<A.size();i++) {
        // do mapy si poznamename pocty a pozice hodnot
        itpocty = pocty.find(A[i]);
        if (itpocty != pocty.end()){
            itpocty->second.second++;
        } else {
            pocty[A[i]]=make_pair(i,1);
        }
        
        
        //zasobnik si pamatuje jen posledni hodnotu a pocet
        //protoze jsou beztak vsechny stejne
        if (sizezasobnik==0) {
            zasobnik=A[i];sizezasobnik++;
        } else {
            if (zasobnik==A[i]) {
                sizezasobnik++;
            } else {
                sizezasobnik--;
            }
        }
    }



    //kontrolni tisk prehledu (hodnota/pozice/pocet)
    cout <<zasobnik <<" - " << sizezasobnik<< endl;
    cout<<"mapa"<< endl;
    for ( itpocty=pocty.begin(); itpocty!=pocty.end(); ++itpocty)
        cout << "hodnota: "<<itpocty->first << "pozice: " << itpocty->second.first
             << " => pocty " << itpocty->second.second << '\n';


    //zaverecne zhodnoceni
    if (sizezasobnik>0) { //je nejakej kandidat na dominatora?
        int tmp1 = pocty[zasobnik].first;
        int tmp2 = pocty[zasobnik].second;
        if (tmp2>(A.size()/2)) //je to dominator?
            return tmp1; //vrat jeho pozici ve vektoru A
        else
            return -1;
    } else {
        return -1;
    }
}

int main() {
    vector<int> A = {3,4,3,2,3,-1,3,3};
    //vector<int> A = {3,4,3,2,4,4,3,-1,4,4,-1,-1,-1,-1,-1,10,-1,-1,-1,3,3};
    cout << solution(A) << endl;
    return 0;
}
----



=== MaxDoubleSliceSum

- _kvůli výkonu jsem se vyhnul zbytečnému používání containeru a vystačil si s aritmetikou ukazatelů. Nejprve jsem si připravil pole horních a dolních suprem součtů a pak už stačilo jen jet po jednotlivých prvcích a hledat maximální součet. Výkon O(n)_

[source,cpp]
----
int solution(vector<int> &A) {
    int ns = A.size();
    int dolni[ns] = { };
    int horni[ns] = { };
    int *uk = A.data();
    int tmp,max=0;
    for (int i=1;i<ns-1;i++) {
        tmp = dolni[i-1]+(*(++uk));
        dolni[i]= (tmp<0)?0:tmp;
    }
    for (int i=ns-2;i>0;i--) {
        tmp = horni[i+1]+(*(uk--));
        horni[i]= (tmp<0)?0:tmp;
    }
    for (int Y=1;Y<ns-1;Y++) {
        tmp = dolni[Y-1]+horni[Y+1];
        max = (tmp>max)?tmp:max;
    }
    return max;
}
----

*Zadání:*

A non-empty zero-indexed array A consisting of N integers is given.

A triplet (X, Y, Z), such that 0 ≤ X < Y < Z < N, is called a double slice.

The sum of double slice (X, Y, Z) is the total of A[X + 1] + A[X + 2] + ... + A[Y − 1] + A[Y + 1] + A[Y + 2] + ... + A[Z − 1].

For example, array A such that:

    A[0] = 3
    A[1] = 2
    A[2] = 6
    A[3] = -1
    A[4] = 4
    A[5] = 5
    A[6] = -1
    A[7] = 2
contains the following example double slices:

double slice (0, 3, 6), sum is 2 + 6 + 4 + 5 = 17,
double slice (0, 3, 7), sum is 2 + 6 + 4 + 5 − 1 = 16,
double slice (3, 4, 5), sum is 0.
The goal is to find the maximal sum of any double slice.

Write a function:

int solution(int A[], int N);
that, given a non-empty zero-indexed array A consisting of N integers, returns the maximal sum of any double slice.

For example, given:

    A[0] = 3
    A[1] = 2
    A[2] = 6
    A[3] = -1
    A[4] = 4
    A[5] = 5
    A[6] = -1
    A[7] = 2
the function should return 17, because no double slice of array A has a sum of greater than 17.

Assume that:

N is an integer within the range [3..100,000];
each element of array A is an integer within the range [−10,000..10,000].
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.


=== Flags

Task description
A non-empty zero-indexed array A consisting of N integers is given.

A peak is an array element which is larger than its neighbours. More precisely, it is an index P such that 0 < P < N − 1 and A[P − 1] < A[P] > A[P + 1].

For example, the following array A:

    A[0] = 1
    A[1] = 5
    A[2] = 3
    A[3] = 4
    A[4] = 3
    A[5] = 4
    A[6] = 1
    A[7] = 2
    A[8] = 3
    A[9] = 4
    A[10] = 6
    A[11] = 2
has exactly four peaks: elements 1, 3, 5 and 10.

You are going on a trip to a range of mountains whose relative heights are represented by array A, as shown in a figure below. You have to choose how many flags you should take with you. The goal is to set the maximum number of flags on the peaks, according to certain rules.



Flags can only be set on peaks. What's more, if you take K flags, then the distance between any two flags should be greater than or equal to K. The distance between indices P and Q is the absolute value |P − Q|.

For example, given the mountain range represented by array A, above, with N = 12, if you take:

two flags, you can set them on peaks 1 and 5;
three flags, you can set them on peaks 1, 5 and 10;
four flags, you can set only three flags, on peaks 1, 5 and 10.
You can therefore set a maximum of three flags in this case.

Write a function:

int solution(vector<int> &A);

that, given a non-empty zero-indexed array A of N integers, returns the maximum number of flags that can be set on the peaks of the array.

For example, the following array A:

    A[0] = 1
    A[1] = 5
    A[2] = 3
    A[3] = 4
    A[4] = 3
    A[5] = 4
    A[6] = 1
    A[7] = 2
    A[8] = 3
    A[9] = 4
    A[10] = 6
    A[11] = 2
the function should return 3, as explained above.

Assume that:

N is an integer within the range [1..400,000];
each element of array A is an integer within the range [0..1,000,000,000].
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.

[source,cpp]
----
#include <iostream>
#include <cmath>
#include <ctime>

int solution(vector<int> &A) {
    int aSize = (int)A.size();
    int maxPeaks = aSize/2;
    int nPeaks = 0;
    int peaks[maxPeaks] = { };

    int i=0;
    while (++i<aSize-1) {
        if ((A[i-1]<A[i])&&(A[i+1]<A[i])) {
            peaks[nPeaks++] = i;
        }
    }

    if (nPeaks<=2) return nPeaks;
    int nejvzdalenejsi = peaks[nPeaks-1]-peaks[0];
    int maxFlags = (int)sqrt(nejvzdalenejsi)+1;
    //cout << "maxfl" << maxFlags << endl;
    for (int pocet = maxFlags;pocet >2;pocet--) {
        int i=1;
        int poc=1;
        int spos = peaks[0];
         while (i<nPeaks) {
            if (spos+pocet<=peaks[i++]) {
                spos=peaks[i-1];poc++;
            }
         }
         if (poc >= pocet) return pocet;
    }
    return 2;
}

vector<int>& fillPole(int i) {
    std::srand(std::time(0)); // use current time as seed for random generator


    static vector<int> tmp (i);
    cout << "{";
    for(int j=0;j<i;j++) {
        int random_variable =
        tmp[j]= int(((double)std::rand()/RAND_MAX)*20);
        cout<<tmp[j]<< ", ";
    }
    cout << "}" << endl;

    return tmp;
}


int main() {

    vector<int> &pks = fillPole(15);
    //vector<int> pks ={5, 8, 7, 0, 6, 0, 8, 16, 10, 14, 10, 16, 12, 17, 2};
    cout << "solution:" << solution(pks) << endl;
}
----


=== Zadání MaxCounters:

You are given N counters, initially set to 0, and you have two possible operations on them:

increase(X) − counter X is increased by 1,
max counter − all counters are set to the maximum value of any counter.
A non-empty zero-indexed array A of M integers is given. This array represents consecutive operations:

if A[K] = X, such that 1 ≤ X ≤ N, then operation K is increase(X),
if A[K] = N + 1 then operation K is max counter.
For example, given integer N = 5 and array A such that:

    A[0] = 3
    A[1] = 4
    A[2] = 4
    A[3] = 6
    A[4] = 1
    A[5] = 4
    A[6] = 4
the values of the counters after each consecutive operation will be:

    (0, 0, 1, 0, 0)
    (0, 0, 1, 1, 0)
    (0, 0, 1, 2, 0)
    (2, 2, 2, 2, 2)
    (3, 2, 2, 2, 2)
    (3, 2, 2, 3, 2)
    (3, 2, 2, 4, 2)
The goal is to calculate the value of every counter after all operations.

Write a function:

vector<int> solution(int N, vector<int> &A);
that, given an integer N and a non-empty zero-indexed array A consisting of M integers, returns a sequence of integers representing the values of the counters.

The sequence should be returned as:

a structure Results (in C), or
a vector of integers (in C++), or
a record Results (in Pascal), or
an array of integers (in any other programming language).
For example, given:

    A[0] = 3
    A[1] = 4
    A[2] = 4
    A[3] = 6
    A[4] = 1
    A[5] = 4
    A[6] = 4
the function should return [3, 2, 2, 4, 2], as explained above.

Assume that:

N and M are integers within the range [1..100,000];
each element of array A is an integer within the range [1..N + 1].
Complexity:

expected worst-case time complexity is O(N+M);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.


[source,cpp]
----
#include <iostream>
#include <vector>
#include <algorithm>

using std::vector;

vector<int> solution(int N, vector<int> &A) {
    vector<int> res;
    //init res
    for(int i=0; i<N; i++) res.push_back(0);

    vector<int>::iterator i;
    int max=0;
    int inf=0;
    for(i=A.begin();i!=A.end();i++)
        if (*i<=N) {
            res[*i-1] = (res[*i-1]<inf)?(inf+1):res[*i-1]+1;
            max = (max>res[*i-1])?max:res[*i-1];
        } else {
           //for (int j=0;j<N;j++) res[j]=max;
            inf=max;
        }
    for (int j=0;j<N;j++) if (res[j]<inf) res[j]=inf;

    return res;
}

----

=== CountDiv

Write a function:

int solution(int A, int B, int K);

that, given three integers A, B and K, returns the number of integers within the range [A..B] that are divisible by K, i.e.:

{ i : A ≤ i ≤ B, i mod K = 0 }

For example, for A = 6, B = 11 and K = 2, your function should return 3, because there are three numbers divisible by 2 within the range [6..11], namely 6, 8 and 10.

Assume that:

A and B are integers within the range [0..2,000,000,000];
K is an integer within the range [1..2,000,000,000];
A ≤ B.
Complexity:

expected worst-case time complexity is O(1);
expected worst-case space complexity is O(1).





[source,cpp]
----

int solution2b(int A, int B, int K) {
    int pom = A%K;
    int st = A+((pom!=0)?(K-pom):0);
    if (st>B)
        return 0;
    int pocet = (B-st)/K;
    return pocet+1;
}
----

=== PassingCars

Task description
A non-empty zero-indexed array A consisting of N integers is given. The consecutive elements of array A represent consecutive cars on a road.

Array A contains only 0s and/or 1s:

0 represents a car traveling east,
1 represents a car traveling west.
The goal is to count passing cars. We say that a pair of cars (P, Q), where 0 ≤ P < Q < N, is passing when P is traveling to the east and Q is traveling to the west.

For example, consider array A such that:

  A[0] = 0
  A[1] = 1
  A[2] = 0
  A[3] = 1
  A[4] = 1
We have five pairs of passing cars: (0, 1), (0, 3), (0, 4), (2, 3), (2, 4).

Write a function:

int solution(vector<int> &A);

that, given a non-empty zero-indexed array A of N integers, returns the number of pairs of passing cars.

The function should return −1 if the number of pairs of passing cars exceeds 1,000,000,000.

For example, given:

  A[0] = 0
  A[1] = 1
  A[2] = 0
  A[3] = 1
  A[4] = 1
the function should return 5, as explained above.

Assume that:

N is an integer within the range [1..100,000];
each element of array A is an integer that can have one of the following values: 0, 1.
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(1), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.


[source,cpp]
----
int solution(vector<int> &A) {


    vector<int>::reverse_iterator i;
    int n1 =0, n0=0, res=0;
    for(i=A.rbegin();i!=A.rend();++i) {
        if (*i) {
            ++n1;
        } else {
            ++n0;
            res+=n1;
            if (res>1000000000) return -1;
        }
    }
    return res;
}
----



== Java


=== MissingInteger

Write a function:

class Solution { public int solution(int[] A); }
that, given a non-empty zero-indexed array A of N integers, returns the minimal positive integer (greater than 0) that does not occur in A.

For example, given:

  A[0] = 1
  A[1] = 3
  A[2] = 6
  A[3] = 4
  A[4] = 1
  A[5] = 2
the function should return 5.

Assume that:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−2,147,483,648..2,147,483,647].
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.

[source,javascript]
----
    public static int solution(int[] A) {
        int [] Z = new int[100000];


            for (int j=0;j<A.length;j++) {
                if ((A[j]>0)&&(A[j]<=100000)) Z[A[j]-1]=1;
            }
            for (int j=0;j<Z.length;j++) if (Z[j]==0) return j+1;
            return 100001;
    }
----




=== FrogRiverOne

A small frog wants to get to the other side of a river. The frog is initially located on one bank of the river (position 0) and wants to get to the opposite bank (position X+1). Leaves fall from a tree onto the surface of the river.

You are given a zero-indexed array A consisting of N integers representing the falling leaves. A[K] represents the position where one leaf falls at time K, measured in seconds.

The goal is to find the earliest time when the frog can jump to the other side of the river. The frog can cross only when leaves appear at every position across the river from 1 to X (that is, we want to find the earliest moment when all the positions from 1 to X are covered by leaves). You may assume that the speed of the current in the river is negligibly small, i.e. the leaves do not change their positions once they fall in the river.

For example, you are given integer X = 5 and array A such that:

  A[0] = 1
  A[1] = 3
  A[2] = 1
  A[3] = 4
  A[4] = 2
  A[5] = 3
  A[6] = 5
  A[7] = 4
In second 6, a leaf falls into position 5. This is the earliest time when leaves appear in every position across the river.

Write a function:

class Solution { public int solution(int X, int[] A); }
that, given a non-empty zero-indexed array A consisting of N integers and integer X, returns the earliest time when the frog can jump to the other side of the river.

If the frog is never able to jump to the other side of the river, the function should return −1.

For example, given X = 5 and array A such that:

  A[0] = 1
  A[1] = 3
  A[2] = 1
  A[3] = 4
  A[4] = 2
  A[5] = 3
  A[6] = 5
  A[7] = 4
the function should return 6, as explained above.

Assume that:

N and X are integers within the range [1..100,000];
each element of array A is an integer within the range [1..X].
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(X), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.

[source,java]
----


    public static int check(boolean[]p, int from) {
        for(int i=from;i<p.length;i++) {
            if (!p[i]) return i-1;
        }
        return p.length-1;
    }

    public static int solution2(int X, int[] A) {
        boolean []p=new boolean[X+1];
        int from=1;

        for(int i=0;i<A.length;i++) {
            if (A[i]<=X) p[A[i]]=true;
            from = check(p,from);
            from = (from<1)?1:from;
            if (from == X) return i;
        }
        //for(int i=0;i<X;i++) System.out.println(p[i]);
        return -1;
    }
----



=== Zadání PermCheck

A non-empty zero-indexed array A consisting of N integers is given.

A permutation is a sequence containing each element from 1 to N once, and only once.

For example, array A such that:

    A[0] = 4
    A[1] = 1
    A[2] = 3
    A[3] = 2
is a permutation, but array A such that:

    A[0] = 4
    A[1] = 1
    A[2] = 3
is not a permutation, because value 2 is missing.

The goal is to check whether array A is a permutation.

Write a function:

class Solution { public int solution(int[] A); }
that, given a zero-indexed array A, returns 1 if array A is a permutation and 0 if it is not.

For example, given array A such that:

    A[0] = 4
    A[1] = 1
    A[2] = 3
    A[3] = 2
the function should return 1.

Given array A such that:

    A[0] = 4
    A[1] = 1
    A[2] = 3
the function should return 0.

Assume that:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [1..1,000,000,000].
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.

[source,javascript]
----
    public static int solution3(int[] A) {
        boolean []p = new boolean[A.length+1];
        for (int i=0;i<A.length;i++) {
            if ((A[i]>=p.length)||(A[i]<1)||(p[A[i]])) return 0; else p[A[i]]=true;
        }
        int i=1;
        while (p[i++] && i<p.length);
        return (i==p.length)?1:0;
    }

----



=== Triangle

- *trojúhelníková nerovnost* - _hodilo mi to 93% správnost, vypadlo to u nějakých extrémních čísel MAXINT - takže zřejmě chybička přetečení. Čas jsem ušetřil na záporných hodnotách, pro které takto pojatá „trojúhelníková nerovnost“ platit nemůže._

Task description
A zero-indexed array A consisting of N integers is given. A triplet (P, Q, R) is triangular if 0 ≤ P < Q < R < N and:

A[P] + A[Q] > A[R],
A[Q] + A[R] > A[P],
A[R] + A[P] > A[Q].
For example, consider array A such that:

  A[0] = 10    A[1] = 2    A[2] = 5
  A[3] = 1     A[4] = 8    A[5] = 20
Triplet (0, 2, 4) is triangular.

Write a function:

class Solution { public int solution(int[] A); }

that, given a zero-indexed array A consisting of N integers, returns 1 if there exists a triangular triplet for this array and returns 0 otherwise.

For example, given array A such that:

  A[0] = 10    A[1] = 2    A[2] = 5
  A[3] = 1     A[4] = 8    A[5] = 20
the function should return 1, as explained above. Given array A such that:

  A[0] = 10    A[1] = 50    A[2] = 5
  A[3] = 1
the function should return 0.

Assume that:

N is an integer within the range [0..100,000];
each element of array A is an integer within the range [−2,147,483,648..2,147,483,647].
Complexity:

expected worst-case time complexity is O(N*log(N));
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.

[source,javascript]
----
class Solution {

    public int solution(int[] A) {
        if (A.length<3) return 0;
        Arrays.sort(A);
        int p=A.length;
        for (int i=A.length-1;i>=0;i--) {
            if ((A[i]+A[i-1]>A[i-2])&&(A[i]+A[i-2]>A[i-1])&&(A[i-2]+A[i-1]>A[i])) {
                return 1;
            }
            if ((--p < 3)||(A[p]<=0)) return 0;
        }
        return 0;
    }

}
----


=== MaxProductOfThree 


Task description
A non-empty zero-indexed array A consisting of N integers is given. The product of triplet (P, Q, R) equates to A[P] * A[Q] * A[R] (0 ≤ P < Q < R < N).

For example, array A such that:

  A[0] = -3
  A[1] = 1
  A[2] = 2
  A[3] = -2
  A[4] = 5
  A[5] = 6
contains the following example triplets:

(0, 1, 2), product is −3 * 1 * 2 = −6
(1, 2, 4), product is 1 * 2 * 5 = 10
(2, 4, 5), product is 2 * 5 * 6 = 60
Your goal is to find the maximal product of any triplet.

Write a function:

class Solution { public int solution(int[] A); }

that, given a non-empty zero-indexed array A, returns the value of the maximal product of any triplet.

For example, given array A such that:

  A[0] = -3
  A[1] = 1
  A[2] = 2
  A[3] = -2
  A[4] = 5
  A[5] = 6
the function should return 60, as the product of triplet (2, 4, 5) is maximal.

Assume that:

N is an integer within the range [3..100,000];
each element of array A is an integer within the range [−1,000..1,000].
Complexity:

expected worst-case time complexity is O(N*log(N));
expected worst-case space complexity is O(1), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.


[source,javascript]
----
import java.util.Arrays;

class Solution {

    public  int solution(int[] A) {
        int tr1,tr2;
        Arrays.sort(A);
        if ((A[0]<0)&&(A[1]<0)) tr1=A[0]*A[1]*A[A.length-1]; else tr1=A[0];
        tr2=A[A.length-1]*A[A.length-2]*A[A.length-3];
        return (tr1<tr2)?tr2:tr1;
    }
}
----

=== NumberOfDiscIntersections

_Na tuto úlohu jsem šel hodně zeširoka - vybudoval jsem si množinu, která mi automaticky rozpoznávala, když jsem tam vložil stejnou dvojici. Bylo nutné předefinovat *hashcode* a *equals* přes vnořenou třídu, pak jsem všechny kružnice seřadil podle spodního okraje, abych v cyklu zastavil vždy u kružnice, která už je mimo rozsah. Program funguje, ale za performance jsem dostal nulu (O(n*n)). Přesto sem toto řešení dávám, protože jsem se na něm hodně naučil. Zřejmě jen stačilo bez řazení a „set„ zásobníku počítat v nořeném cyklu překrývající objekty._

Task description
We draw N discs on a plane. The discs are numbered from 0 to N − 1. A zero-indexed array A of N non-negative integers, specifying the radiuses of the discs, is given. The J-th disc is drawn with its center at (J, 0) and radius A[J].

We say that the J-th disc and K-th disc intersect if J ≠ K and the J-th and K-th discs have at least one common point (assuming that the discs contain their borders).

The figure below shows discs drawn for N = 6 and A as follows:

  A[0] = 1
  A[1] = 5
  A[2] = 2
  A[3] = 1
  A[4] = 4
  A[5] = 0


There are eleven (unordered) pairs of discs that intersect, namely:

discs 1 and 4 intersect, and both intersect with all the other discs;
disc 2 also intersects with discs 0 and 3.
Write a function:

class Solution { public int solution(int[] A); }

that, given an array A describing N discs as explained above, returns the number of (unordered) pairs of intersecting discs. The function should return −1 if the number of intersecting pairs exceeds 10,000,000.

Given array A shown above, the function should return 11, as explained above.

Assume that:

N is an integer within the range [0..100,000];
each element of array A is an integer within the range [0..2,147,483,647].
Complexity:

expected worst-case time complexity is O(N*log(N));
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.


[source,java]
----
import java.util.Arrays;
import java.util.Set;
import java.util.HashSet;

class Solution {
    static class Kamosi {
        int prvni,druhy;

        Kamosi(int x, int y) {
           prvni=x;druhy=y;
        }
        public boolean equals(Object obj) {
            Kamosi druhadvojice = (Kamosi)obj;
            return ((prvni==druhadvojice.prvni)&&(druhy==druhadvojice.druhy))||
                    ((prvni==druhadvojice.druhy)&&(druhy==druhadvojice.prvni));
        }
        public int hashCode(){
                 return prvni+druhy;
        }
        public String toString() {
            String kamosiInfo = "Kruznice " + prvni+" a kruznice "+druhy + " se dotykaji";
            return kamosiInfo;
        }

    }
    
    static Set<Kamosi> dotykajici = new HashSet<>();

    public static void pridejKamose(int i, int j) {
        dotykajici.add(new Kamosi(i,j));
    }

    public static void vypisKamose() {
       dotykajici.forEach(System.out::println);
    }

    public static boolean najdiKamose(int stred, int polomer,  int[][]psA1) {
        int i=0;
        while (psA1[i][1]<=(stred+polomer))  {
            if (((stred-polomer)<=psA1[i][2])&&(stred != psA1[i][0])) {
                pridejKamose(stred,psA1[i][0]);
            }
            if (psA1.length == ++i) break;
        }
       return dotykajici.size()>10000000;
    }


   
    public int solution(int[] A) {       
       int[][] sA1 = new int[A.length][3];
       if (A.length<2) return 0;
       for (int i=0;i<A.length;i++) {
          sA1[i][0]=i;sA1[i][1]=i-A[i];sA1[i][2]=i+A[i];
       }
       //sort podle spodniho okraje
       Arrays.sort(sA1,(a,b)->a[1]-b[1]);

       for (int i=0;i<A.length;i++) {
           if (najdiKamose(i,A[i],sA1)) return -1;
       }
    
       return dotykajici.size();


    }


}
----

=== MaxProfit

- _po prostudování podobné úlohy na maximální slice, bylo tohle již snadné -> 100%, O(n). Algoritmus je to ale krásný..._

[source,javascript]
----
class Solution {
    
    public  int solution(int[] A) {
        if (A.length==0) return 0;
        int minend=A[0], maxend=0, maxprofit=0;

        for (int i=1;i<A.length;i++) {
            maxend = Math.max(0,A[i]-minend); //poznamenávám si jen maximální profit k tomuto dni
            minend = Math.min(minend,A[i]);   //připravuji si minimální koupi pro budoucí maxend
            maxprofit = Math.max(maxprofit, maxend); //poznamenávám si maximální dosažený profit ze všech maxendů
        }
        return (maxprofit>0)?maxprofit:0;
    }
}
----



Task description
A zero-indexed array A consisting of N integers is given. It contains daily prices of a stock share for a period of N consecutive days. If a single share was bought on day P and sold on day Q, where 0 ≤ P ≤ Q < N, then the profit of such transaction is equal to A[Q] − A[P], provided that A[Q] ≥ A[P]. Otherwise, the transaction brings loss of A[P] − A[Q].

For example, consider the following array A consisting of six elements such that:

  A[0] = 23171
  A[1] = 21011
  A[2] = 21123
  A[3] = 21366
  A[4] = 21013
  A[5] = 21367
If a share was bought on day 0 and sold on day 2, a loss of 2048 would occur because A[2] − A[0] = 21123 − 23171 = −2048. If a share was bought on day 4 and sold on day 5, a profit of 354 would occur because A[5] − A[4] = 21367 − 21013 = 354. Maximum possible profit was 356. It would occur if a share was bought on day 1 and sold on day 5.

Write a function,

class Solution { public int solution(int[] A); }

that, given a zero-indexed array A consisting of N integers containing daily prices of a stock share for a period of N consecutive days, returns the maximum possible profit from one transaction during this period. The function should return 0 if it was impossible to gain any profit.

For example, given array A consisting of six elements such that:

  A[0] = 23171
  A[1] = 21011
  A[2] = 21123
  A[3] = 21366
  A[4] = 21013
  A[5] = 21367
the function should return 356, as explained above.

Assume that:

N is an integer within the range [0..400,000];
each element of array A is an integer within the range [0..200,000].
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(1), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.




== Python

=== MinAvgTwoSlice

*Tak u této úlohy jsem si vylámal zuby. Nejprve jsem to musel předělat pro interpret 2.7 a i pak jsem po vyhodnocení zjistil, že je můj kod zoufale pomalý (O(n*n)) a dokonce u jednoho nespecifikovaného vstupu vyhodil chybu. Bohužel je tento vstup utajený a tak chybu nemohu odtrasovat. I přes hodnocení 50% sem své řešení uvádím, třeba mě někdy něco napadne, nebo někdo poradí :-)*

- _inspirace od google-> že by stačilo hledat pouze slices velikosti 2 a 3, protože ty větší se z nich skládají, zřejmě vede k větší rychlosti, nebylo by dokonce potřeba vytvářet prefixsums, ale dle mého názoru vytváří teoretickou možnost chybného výsledku, protože průměr průměrů není průměr. Kdo-ví - jestli v tomto případě nejde o tu „chybu“, kterou mi Codility detekovalo! ;-)_


Task description
A non-empty zero-indexed array A consisting of N integers is given. A pair of integers (P, Q), such that 0 ≤ P < Q < N, is called a slice of array A (notice that the slice contains at least two elements). The average of a slice (P, Q) is the sum of A[P] + A[P + 1] + ... + A[Q] divided by the length of the slice. To be precise, the average equals (A[P] + A[P + 1] + ... + A[Q]) / (Q − P + 1).

For example, array A such that:

    A[0] = 4
    A[1] = 2
    A[2] = 2
    A[3] = 5
    A[4] = 1
    A[5] = 5
    A[6] = 8
contains the following example slices:

slice (1, 2), whose average is (2 + 2) / 2 = 2;
slice (3, 4), whose average is (5 + 1) / 2 = 3;
slice (1, 4), whose average is (2 + 2 + 5 + 1) / 4 = 2.5.
The goal is to find the starting position of a slice whose average is minimal.

Write a function:

def solution(A)

that, given a non-empty zero-indexed array A consisting of N integers, returns the starting position of the slice with the minimal average. If there is more than one slice with a minimal average, you should return the smallest starting position of such a slice.

For example, given array A such that:

    A[0] = 4
    A[1] = 2
    A[2] = 2
    A[3] = 5
    A[4] = 1
    A[5] = 5
    A[6] = 8
the function should return 1, as explained above.

Assume that:

N is an integer within the range [2..100,000];
each element of array A is an integer within the range [−10,000..10,000].
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.


[source,python]
----

def makepref(A):
    """vytvoření mezisoučtů"""

    s=0;
    pref = [s]
    for i in A:
        s+=i
        pref.append(s)
    return pref

def getmindif(Pref, d):
    """vrátí dvojici počáteční pozici a nejmenší nalezený průměr
       Pref -> prefix sums zadaného pole A
       d -> jak daleko od sebe P a Q 
    """
    dif = [(i, Pref[i+d]-Pref[i]) for i in range(len(Pref)-d)]
    m = reduce((lambda a,b: a if a[1]<b[1] else b),dif)
    return (m[0],float(m[1])/d)

def solution(A):
    pref=makepref(A) # vytvoří prefixsums
    min=getmindif(pref,2) # vybere nejmenší dvojici
    for i in range(3,len(A)+1): #zkouší další n-tice
        m=getmindif(pref,i)
        if (m[1]<min[1]) or ((m[1] == min[1]) and (m[0]<min[0])): # pokud menší, nebo alespoň blíže počátku
            min=m
    return min[0]
----


=== Brackets

Task description
A string S consisting of N characters is considered to be properly nested if any of the following conditions is true:

S is empty;
S has the form "(U)" or "[U]" or "{U}" where U is a properly nested string;
S has the form "VW" where V and W are properly nested strings.
For example, the string "{[()()]}" is properly nested but "([)()]" is not.

Write a function:

def solution(S)

that, given a string S consisting of N characters, returns 1 if S is properly nested and 0 otherwise.

For example, given S = "{[()()]}", the function should return 1 and given S = "([)()]", the function should return 0, as explained above.

Assume that:

N is an integer within the range [0..200,000];
string S consists only of the following characters: "(", "{", "[", "]", "}" and/or ")".
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N) (not counting the storage required for input arguments).

[source,python]
----
def solution(S):
    zasobnik = []
    lb = ['[', '{', '(']
    rb = [']', '}', ')']
    for z in S:
        if z in lb:
            zasobnik.append(z)
        if z in rb:
            if len(zasobnik) == 0:
                return 0
            ch = zasobnik.pop()
            if rb[lb.index(ch)] != z:
                return 0
    return 1 if len(zasobnik)==0 else 0
----

=== Fish

- _v okamžiku kdy jedna ryba sežrala druhou, otočil jsem směr kontroly a jel obráceně. Vše jsem řešil jedním cyklem bez volání funkcí, kvůli výkonu jsem nemazal prvky z pole, ani jsem je nijak nevkládal -> pouze přepisoval hodnotu. U „large-random nad 100000 ryb“ testu jsem ale neprošel - zřejmě se mi cyklus zbytečně proplétal přes prázdná pole. 87% mi u této úlohy postačuje, protože vím, jak bych to mohl urychlit - na začátku dlouhého prázdného místa bych si poznamenal, kam mám s ukazatelem polohy rovnou skočit_

Task description
You are given two non-empty zero-indexed arrays A and B consisting of N integers. Arrays A and B represent N voracious fish in a river, ordered downstream along the flow of the river.

The fish are numbered from 0 to N − 1. If P and Q are two fish and P < Q, then fish P is initially upstream of fish Q. Initially, each fish has a unique position.

Fish number P is represented by A[P] and B[P]. Array A contains the sizes of the fish. All its elements are unique. Array B contains the directions of the fish. It contains only 0s and/or 1s, where:

0 represents a fish flowing upstream,
1 represents a fish flowing downstream.
If two fish move in opposite directions and there are no other (living) fish between them, they will eventually meet each other. Then only one fish can stay alive − the larger fish eats the smaller one. More precisely, we say that two fish P and Q meet each other when P < Q, B[P] = 1 and B[Q] = 0, and there are no living fish between them. After they meet:

If A[P] > A[Q] then P eats Q, and P will still be flowing downstream,
If A[Q] > A[P] then Q eats P, and Q will still be flowing upstream.
We assume that all the fish are flowing at the same speed. That is, fish moving in the same direction never meet. The goal is to calculate the number of fish that will stay alive.

For example, consider arrays A and B such that:

  A[0] = 4    B[0] = 0
  A[1] = 3    B[1] = 1
  A[2] = 2    B[2] = 0
  A[3] = 1    B[3] = 0
  A[4] = 5    B[4] = 0
Initially all the fish are alive and all except fish number 1 are moving upstream. Fish number 1 meets fish number 2 and eats it, then it meets fish number 3 and eats it too. Finally, it meets fish number 4 and is eaten by it. The remaining two fish, number 0 and 4, never meet and therefore stay alive.

Write a function:

def solution(A, B)

that, given two non-empty zero-indexed arrays A and B consisting of N integers, returns the number of fish that will stay alive.

For example, given the arrays shown above, the function should return 2, as explained above.

Assume that:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [0..1,000,000,000];
each element of array B is an integer that can have one of the following values: 0, 1;
the elements of A are all distinct.
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.


[source,python]
----
def solution(A, B):
   smer=[[False,-1],[False,-1]]
   i=0
   sezrano=False
   pocetsezranych = 0
   kam = 1
   while True:
      if B[i]!=-1:
          if B[i]==kam:
             smer[kam]=[True,i]
          if (B[i]== (not kam)) and smer[kam][0]:
             sezrano=True
             pocetsezranych+=1
             if A[smer[kam][1]]>A[i]:
                B[i]=-1
             else:
                B[smer[kam][1]]=-1
                smer[kam]=[False,-1]
                kam = not kam
                smer[kam]=[True,i]
      i+=1 if kam else -1
      if i==-1:
         if not sezrano:
           break
         sezrano=False
         i=0
         kam = 1
         smer=[[False,-1],[False,-1]]
      if i==len(B):
         if not sezrano:
            break
         sezrano=False
         i=len(B)-1
         kam=0
         smer=[[False,-1],[False,-1]]
   return len(A)-pocetsezranych
----


=== StoneWall

- _původní řešení, kde jsem se jen opřel o filtry, mělo slabý výkon O(n*n):_

[source,python]
----
def solution(H):
    hladiny = []
    pocet = 0
    for i in H:
        if i in hladiny:
            hladiny = [h for h in hladiny if h<=i]
            continue
        else:
            hladiny = [h for h in hladiny if h<i]
            hladiny.append(i)
            pocet+=1
    return pocet
----

- _po uvědomění, že hladiny, které mám rušit se nachází vždy až na konci seznamu hladin, jsem výkon zvýšil na O(n):_

[source,python]
----
def solution(H):
    hladiny = []
    pocet = 0
    for i in H:
        if len(hladiny)>0:
            while len(hladiny)>0 and (hladiny[-1]>i) :
                hladiny.pop()
        if len(hladiny)>0 and i == hladiny[-1]:
            continue
        else:
            hladiny.append(i)
            pocet+=1
    return pocet
----




Task description
You are going to build a stone wall. The wall should be straight and N meters long, and its thickness should be constant; however, it should have different heights in different places. The height of the wall is specified by a zero-indexed array H of N positive integers. H[I] is the height of the wall from I to I+1 meters to the right of its left end. In particular, H[0] is the height of the wall's left end and H[N−1] is the height of the wall's right end.

The wall should be built of cuboid stone blocks (that is, all sides of such blocks are rectangular). Your task is to compute the minimum number of blocks needed to build the wall.

Write a function:

def solution(H)

that, given a zero-indexed array H of N positive integers specifying the height of the wall, returns the minimum number of blocks needed to build it.

For example, given array H containing N = 9 integers:

  H[0] = 8    H[1] = 8    H[2] = 5
  H[3] = 7    H[4] = 9    H[5] = 8
  H[6] = 7    H[7] = 4    H[8] = 8
the function should return 7. The figure shows one possible arrangement of seven blocks.



Assume that:

N is an integer within the range [1..100,000];
each element of array H is an integer within the range [1..1,000,000,000].
Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
Elements of input arrays can be modified.



